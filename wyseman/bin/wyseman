#!/usr/bin/env ruby
#Command line interface for managing a schema in wyseman
#TODO:
#X- Implement initialization files .wmi
#X- Output SQL build files for app-level database generation
#- How to input/update table migration scripts (such as changing column names, adding or deleting columns)
#- Manage releases:
#-   Move SQL output code to a separate module
#-   Generate a version code when SQL build code is generated
#-   Can generate SQL for any past version still in the database
#-   Can generate sql to upgrade existing database to a specified release specification
#- Dump selected, or all tables
#- Restore selected or all tables
#- List database objects in dependency/tree order
#- 

require 'optparse'
require 'fileutils'
require 'csv'
require 'wyseman'
require 'wyseman/db'

opts = {test:nil, dbname:nil, host:'localhost', repl:nil, prune:true, drop:true, post:true, make:true, branch:'', work:'/var/tmp/wyseman'}

OptionParser.new do |op|
    op.banner = "Usage: wyseman [opts] source_file(s)"
    op.on('-?', '--help', 'Show help message') {STDERR.puts opts; exit}
    op.on('-n', '--dbname=name', 'Specify the database name explicitly (rather than defaulting to the username)') {|v| opts[:dbname] = v}
    op.on('-h', '--host=name', 'Specify the database host name explicitly (rather than defaulting to the username)') {|v| opts[:host] = v}
    op.on('-r', '--replace', 'Replace views/functions where possible') {opts[:repl] = true}
    op.on('-m', '--[no-]make', 'Build any uninstantiated objects in the database') {|v| opts[:make] = v}
    op.on('-p', '--[no-]prune', 'Remove any objects no longer in the source file(s)') {|v| opts[:prune] = v}
    op.on('-d', '--[no-]drop', 'Any objects no longer in the source file(s)') {|v| opts[:drop] = v}
    op.on('-z', '--[no-]post', 'Run the post-parse cleanup scans (default behavior)') {|v| opts[:post] = v}
    op.on('-b', '--branch=object', 'Include the specified object and all others that depend on it') {|v| opts[:branch] += v + ' '}
    op.on('-s', '--[no-]sql', 'Write schema creation SQL to stdout') {|v| opts[:sql] = v}
    op.on('-i', '--[no-]init', 'Write initialization SQL to stdout (as opposed to executing it in the DB)') {|v| opts[:init] = v}
#    op.on('-w', '--work=dir', '') {|v| opts[:work] = v}
#    op.on('-t', '--test', 'Show what would happen, but make no actual changes') {opts[:test] = true}
#    op.on('-n', '--nowarn', "Don't give warnings for dropping populated tables") {opts[:warn] = false}
#    op.on('-z', '--zz xx', '') {|v| opts[:x] = v}
end.parse!
#p 'Opts:',opts; p 'Args:',ARGV			#Debug

#Fixme: turn back on when dump/restore implemented
#FileUtils::mkdir_p opts[:work]			#Make sure working directory exists

dbc = Wyseman::DB.new(dbname:opts[:dbname], host:opts[:host])	#Connect to postgres, will make sure bootstrap/ddict exists
post_sql = ''
if ARGV.length > 0
  wm = Wyseman::Session.new(dbc)		#Initialize the parser
  ARGV.each {|f| 				#Parse the specified input files
    exit if !(sql = wm.parse(f))
    post_sql << sql				#accumulate for later
  }
  if opts[:post]				#And do post-cleanup
    wm.check(opts[:prune])
  else
    exit 0					#No post-cleanup, so get out now
  end
  wm.destroy()					#Done with our interpretor
end

if opts[:branch] == ''				#If no branches specified
  brval = 'null'				#Default to all dirty objects
else
  brval = "'{" + opts[:branch].strip.split(' ').join(',') + "}'"
end

#Instantiate specified, or default objects in the database, with optional pre-drop
if opts[:make] 
  if dbc.one("select wm.make(#{brval},#{opts[:drop]},true);")[0].to_i > 0	#Make objects
    dbc.x("select wm.init_dictionary();")				#dictionary
  end
end

# -----------------------------------------------------------------------------
if opts[:sql]					#Generate schema creation SQL on stdout
  puts "--Schema Creation SQL:\nbegin;\ncreate schema wm;"

  puts %Q{create or replace function wm.create_group(grp varchar) returns boolean language plpgsql as $$
  begin\n    if not exists (select rolname from pg_roles where rolname = grp) then
      execute 'create role ' || grp || ';'; return true;
    end if;\n    return false;\n  end;\n$$;}
  
  roles = []					#Keep track of roles we have created
  dbc.x("select obj_nam,crt_sql,grants from wm.objects_v_depth where release = wm.release() order by depth,obj_nam").values.each {|row|
#    puts "--Create #{row[0]}:"
    puts row[1]
    CSV.parse(row[2].delete("{}")).each {|row|		#For each grant record
      row.each {|grec|
#printf("Grec:%s\n", grec)
        obj_nam, mod, level, priv = grec.split(',')
        otyp, onam = obj_nam.split(':')
        perm = (mod == 'public') ? mod : mod.to_s + '_' + level.to_s
        otyp = (otyp == 'view') ? 'table' : otyp
        if !roles.include?(perm) && perm != 'public'
          puts "select wm.create_group('#{perm}');"
          roles << perm 
        end
        puts "grant #{priv} on #{otyp} #{onam} to #{perm};"
      }
    }
  }

  puts "\n--Data Dictionary:"
  %w{wm.table_text wm.column_text wm.value_text wm.message_text wm.table_style wm.column_style wm.column_native}.each {|tab|
    flds = dbc.one("select array_to_string(array(select col from wm.column_pub where obj = '#{tab}' order by field),',')")[0]
#printf("flds:%s\n",flds)
    printf("insert into #{tab} (%s) values\n", flds)
    irows = []
    res = dbc.x("select #{flds} from #{tab}")
    for i in 0..(res.ntuples-1)
      row = res[i]
#printf("row:%s\n",row)
      icols = []
      flds.split(',').each {|f|
#printf(" f:%s col:%s\n", f, row[f])
        icols << dbc.quote(tab,f,row[f])
      }
      irows << ("(" + icols.join(',') + ")")
    end
    puts "  " + irows.join(",\n  ") + ";\n\n"
  }
end

if post_sql != ''				#Initialization of table data
  if opts[:init] || opts[:sql]
    puts "--Initialization SQL:"
    puts post_sql				#See initialization code on stdout
    puts "commit;"
  else
    STDERR.puts "Running Initialization SQL"
    dbc.x(post_sql)
  end
end
